<html>
<head>
<title>Knifetank!</title>
<script type="text/javascript" src="processing/processing-0.9.1.js"></script>
<script type="text/javascript" src="processing/init.js"></script>
<audio src="music/leveltwo01.wav" preload="true" id="track1"></audio>
<audio src="music/leveltwo02.wav" preload="true" id="track2"></audio>
<audio src="music/leveltwo03.wav" preload="true" id="track3"></audio>
<audio src="music/leveltwo04.wav" preload="true" id="track4"></audio>
<audio src="music/leveltwo05.wav" preload="true" id="track5"></audio>
<audio src="music/leveltwo01.ogg" preload="true" id="track11"></audio>
<audio src="music/leveltwo02.ogg" preload="true" id="track12"></audio>
<audio src="music/leveltwo03.ogg" preload="true" id="track13"></audio>
<audio src="music/leveltwo04.ogg" preload="true" id="track14"></audio>
<audio src="music/leveltwo05.ogg" preload="true" id="track15"></audio>
<style type="text/css">
body {background: #000 url("art_assets/knifetankbackground.png") no-repeat;}
</style>
<script type="application/processing">

int numAudioFiles = 5;
int audioIndex = 1;

boolean showBBs = true; // DEBUG: show bounding boxes.

PFont font = loadFont("Arial-MT",15);
PImage tank1;
PImage tank2;
PImage tank3;
PImage ghostank1;
PImage ghostank2;
PImage ghostank3;
ArrayList cannons;
ArrayList bullets;
ArrayList targets;
ArrayList walls;

int points = 0;
int bulletCounter = 0;
int hitCounter = 0;
float accuracy;
int seconds = 0;
int sc = 0;
int speed = 20;
boolean playing = false;
boolean win = false;

class Wall {
  float x;
  float y;
  float d = 70;
  boolean on;
  Wall(float X, float Y, boolean ON) {
    x = X;
    y = Y;
    on = ON;
  }
  float top()    { return y - d/2; }
  float bottom() { return y + d/2; }
  float left()   { return x - d/2; }
  float right()  { return x + d/2; }

  boolean intersect(PVector p1, PVector p2) {
    return false;
  }
  void show() {
    stroke(0,0,0,255);
    strokeWeight(2);
    int hue = 200;
    if (on) {
      fill(255,255,0);
    }
    else {
      fill(255,0,255);
    }
    rect(x-d/2,y-d/2,d,d);

    for (int i=0;i<bullets.size();i++) {
      Bullet b = bullets.get(i);
      PVector l = new PVector(b.loc.x,b.loc.y);
      PVector dir = new PVector(b.dir.x,b.dir.y);
      if (l.x>=x-d/2&&l.x<=x+d/2&&l.y >=y-d/2&&l.y<=y+d/2) {
        on = !on;

	// switch to the next audio track
        var prev = getTrack(audioIndex);
        audioIndex += 1;
        if (audioIndex > numAudioFiles)
          audioIndex = 1;
        var next = getTrack(audioIndex);
        next.volume = 0;
        next.play();
        next.currentTime = prev.currentTime;  
        next.volume = 1;
        prev.volume = 0;
        prev.pause();

        // reflect the bullet
        if (dir.x == 0) {
          (bullets.get(i)).flipy(); 
        }
        else if (dir.y == 0) {
          (bullets.get(i)).flipx(); 
        }
        else {
          float dx = 0;
          if (dir.x > 0) {
            dx = l.x - (x-d/2);
          }
          else {
            dx = l.x - (x+d/2);
          }
          float dy = dx*dir.y/dir.x;         

          float yy = l.y - dy;
          if (yy==y-d/2 || yy == y+d/2) {
            (bullets.get(i)).flipx();
            (bullets.get(i)).flipy();
          } 
          else if (yy>y-d/2 && yy < y+d/2) {
            (bullets.get(i)).flipx();
          }
          else {
            (bullets.get(i)).flipy(); 
          }
        }
      }  
    }
  }
}

class Bullet
{
  PVector loc = new PVector();
  PVector dir = new PVector();
  float angle;
  Cannon c;
  int age = 0;
  boolean alive;
  Bullet(Cannon c, float x, float y)
  {
    this.c = c;
    loc.x = x;
    loc.y = y;
    PVector center = new PVector(c.loc.x,c.loc.y);
    PVector turret = new PVector(c.cX,c.cY);
    dir = PVector.sub(turret, center);
    alive = true;
  }
  void run()
  {
    noStroke();
    fill(100);
    ellipse(loc.x,loc.y,10,10);
    loc.add(new PVector(dir.x/4,dir.y/4));
    if (loc.x < 0 || loc.x > width)
      flipx();
    if (loc.y < 0 || loc.y > height)
      flipy();
    age++;
    if (age>100)  alive = false;
  }
  void flipx()
  {
    dir.x = -dir.x;
  }
  void flipy()
  {
    dir.y = -dir.y;
  }
}

class Target
{
  PVector loc;
  float d = 70;
  int lives;
  boolean alive;
  float speed = 3;
  int sprite = 0;
  float angle = 0; // angle to which we rotate to draw the sprite. radians.

  Target(float X, float Y, int LIVES)
  {
    loc = new PVector();
    loc.x = X;
    loc.y = Y;
    this.lives = LIVES;
    alive = true;
  }

  float top()    { return loc.y - d/2; }
  float bottom() { return loc.y + d/2; }
  float left()   { return loc.x - d/2; }
  float right()  { return loc.x + d/2; }

  void show()
  {

     // This switch moves enemies randomly (disabled)
     int r = -1;//int(random(10));
     switch(r) {
       case 1: moveLeft(speed);  angle = -PI/2; break;
       case 2: moveRight(speed); angle = PI/2;  break;
       case 3: moveUp(speed);    angle = PI;    break;
       case 4: moveDown(speed);  break; // angle = 0
     }

     // This loop moves enemies "intelligently"
     for (int i = 0; i < cannons.size(); ++i) {
       Cannon c = cannons.get(i);
       float oldx = loc.x;
       float oldy = loc.y;
       if (c.loc.x < left()) {
         moveLeft(speed);
         angle = PI/2;        
         if (loc.x != oldx || loc.y != oldy) {
            break;
         }
       }
       if (c.loc.x > right()) {
         moveRight(speed); 
         angle = -PI/2;
         if (loc.x != oldx || loc.y != oldy) {
            break;   
         }
       }
       if (c.loc.y < top()) {
         moveUp(speed);  
         angle = PI;
         if (loc.x != oldx || loc.y != oldy) {
            break;
         }
       }
       if (c.loc.y > bottom()) {
         moveDown(speed);
         angle = 0;
         if (loc.x != oldx || loc.y != oldy) {
            break;
         }
       }
     }

    translate(loc.x,loc.y);
    rotate(angle);
    switch (sprite) {
      case 0: image(ghostank1,-d/2,-d/2); break;
      case 1: image(ghostank2,-d/2,-d/2); break;
      case 2: image(ghostank3,-d/2,-d/2); break;
    }
    if (sc % 2 == 0) {
     sprite = (sprite+1)%3;
    }
    rotate(-angle);
    translate(-loc.x,-loc.y);
    
    if (showBBs) {
      strokeWeight(1);
      noFill();
      stroke(0,0,255);
      rect(loc.x-d/2,loc.y-d/2,d,d);
    }
    for (int i=0;i<bullets.size();i++)
    {
      Bullet b = bullets.get(i);
      if (!b.alive) continue;

      PVector l = new PVector(b.loc.x,b.loc.y);
      if (l.x>=left()&&l.x<=right()&&l.y >=top()&&l.y<=bottom()) {
        lives--;
        hitCounter++;
        bullets.remove(b);
        if (lives <= 0) { 
          points++;
          alive = false;
        }  
      }  
    }
    for (int i=0;i<cannons.size();i++)
    {
      fill(255);
      Cannon c = cannons.get(i);
      float minx = left()   - c.d/2;
      float maxx = right()  + c.d/2;
      float miny = top()    - c.d/2;
      float maxy = bottom() + c.d/2;

      if (c.loc.x>=minx && c.loc.x<=maxx && c.loc.y >= miny && c.loc.y <= maxy)
      {
         //FIXME: This collision detection is a little soft.
         playing = false;
      }  
    }

  }

 void moveUp(float dy) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.left()   - d/2;
      float maxx = wall.right()  + d/2;
      float miny = wall.bottom() + d/2;
      float maxy = wall.bottom() + d/2 + dy;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dy = top() - wall.bottom();
      }
    }
    loc.y -= dy

    if (top() < 0) {
      loc.y = d/2;
    } 
  }

  void moveDown(float dy) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.left() - d/2;
      float maxx = wall.right() + d/2;
      float miny = wall.top() - d/2 - dy;
      float maxy = wall.top() - d/2;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dy = wall.top() - bottom();
      }
    }
    loc.y += dy

    if (bottom() > height) {
      loc.y = height-d/2;
    }
  }

  void moveLeft(float dx) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.right()  + d/2;
      float maxx = wall.right()  + d/2 + dx;
      float miny = wall.top()    - d/2;
      float maxy = wall.bottom() + d/2;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dx = left() - wall.right();
      }
    }
    loc.x -= dx

    if (left() < 0) {
      loc.x = d/2;
    }
  }
  void moveRight(float dx) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.left()   - d/2 - dx;
      float maxx = wall.left()   - d/2;
      float miny = wall.top()    - d/2;
      float maxy = wall.bottom() + d/2;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dx = wall.left() - right();
      }
    }
    loc.x += dx

    if (right() > width) {
      loc.x = width-d/2;
    }
  }
}

class Cannon {
  float d;
  float r;
  float cX;
  float cY;
  PVector loc = new PVector();
  int sprite = 0;
  float baseAngle = 0;
  float firing = 0;
  Cannon(float x, float y) {
    d = 70;
    r = d/2;
    loc.x = x;
    loc.y = y;
  }
  float top()    { return loc.y - d/2; }
  float bottom() { return loc.y + d/2; }
  float left()   { return loc.x - d/2; }
  float right()  { return loc.x + d/2; }

  void show() {
    smooth();

    float angle = atan2(mouseY-loc.y,mouseX-loc.x);

    cX = (r * cos(angle)) + loc.x;
    cY = (r * sin(angle)) + loc.y;

    translate(loc.x,loc.y);
    rotate(baseAngle-PI/2);
    switch (sprite) {
      case 0: image(tank1,-d/2,-d/2); break;
      case 1: image(tank2,-d/2,-d/2); break;
      case 2: image(tank3,-d/2,-d/2); break;
    }
    rotate(-baseAngle+PI/2);
    switch (firing) {
      //case 0: image(turret1,-d/2,-d/2); break;
      //case 1: image(turret2,-d/2,-d/2); break;
      //case 2: image(turret3,-d/2,-d/2); break;
      //case 3: image(turret3,-d/2,-d/2); break;
    }
    if (firing > 0) --firing;
    rotate(angle - PI/2);
    // draw the turret sprite here.
    rotate(-angle+PI/2);
    translate(-loc.x,-loc.y);
    
    if (showBBs) {
      // show bounding box
      noFill();
      strokeWeight(1);
      stroke(0,255,0);
      rect(loc.x-d/2,loc.y-d/2,d,d);
      line(loc.x,loc.y,cX,cY);
    }
  }  
  
 void moveUp(float dy) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.left()   - d/2;
      float maxx = wall.right()  + d/2;
      float miny = wall.bottom() + d/2;
      float maxy = wall.bottom() + d/2 + dy;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dy = top() - wall.bottom();
      }
    }
    loc.y -= dy

    if (top() < 0) {
      loc.y = d/2;
    }
    sprite = (sprite+1)%3;
    baseAngle = -PI/2;
  }

  void moveDown(float dy) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.left() - d/2;
      float maxx = wall.right() + d/2;
      float miny = wall.top() - d/2 - dy;
      float maxy = wall.top() - d/2;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dy = wall.top() - bottom();
      }
    }
    loc.y += dy

    if (bottom() > height) {
      loc.y = height-d/2;
    }
    sprite = (sprite+1)%3;
    baseAngle = PI/2;
  }

  void moveLeft(float dx) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.right()  + d/2;
      float maxx = wall.right()  + d/2 + dx;
      float miny = wall.top()    - d/2;
      float maxy = wall.bottom() + d/2;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dx = left() - wall.right();
      }
    }
    loc.x -= dx

    if (left() < 0) {
      loc.x = d/2;
    }
    sprite = (sprite+1)%3;
    baseAngle = PI;
  }
  void moveRight(float dx) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.left()   - d/2 - dx;
      float maxx = wall.left()   - d/2;
      float miny = wall.top()    - d/2;
      float maxy = wall.bottom() + d/2;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dx = wall.left() - right();
      }
    }
    loc.x += dx

    if (right() > width) {
      loc.x = width-d/2;
    }
    sprite = (sprite+1)%3;
    baseAngle = 0;
  }

  void fire() {
     firing = 3;
  } 
}

void setup() {
  cannons = new ArrayList();
  bullets = new ArrayList();
  targets = new ArrayList();
  walls   = new ArrayList();
  points = 0;
  targetInterval = 150;
  counter = 0;
  bulletCounter = 0;
  hitCounter = 0;
  accuracy = 0;
  seconds = 0;
  sc = 0;
  c = 0;
  speed = 10;
  size(960,640);
  cursor(CROSS);
  textFont(font);
  for (int i=0; i < 5; ++i) {
    walls.add(new Wall(i*100+100,random(50,425),true));
    targets.add(new Target(random(50,425),random(50,425),1));
  }
  cannons.add(new Cannon(width/2,height/2));
  win = false;
  playing = true;
  frameRate(50);

  tank1 = loadImage("art_assets/tank01sm.png");
  tank2 = loadImage("art_assets/tank02sm.png");
  tank3 = loadImage("art_assets/tank03sm.png");
  ghostank1 = loadImage("art_assets/ghostank01sm.png");
  ghostank2 = loadImage("art_assets/ghostank02sm.png");
  ghostank3 = loadImage("art_assets/ghostank03sm.png");

  var audioElement = getTrack(1);
  audioElement.load();
  audioElement.loop = true;
  audioElement.volume = 1;
  audioElement.play();

  for (int i=2; i <= numAudioFiles; ++i) {
    var audioElement = document.getElementById("track"+str(i));
    audioElement.load();
    audioElement.loop = true;
    audioElement.volume = 0;
  }
}

void draw()
{
  if (playing)
    play();
  else
    gameover();
}

void play()
{
  font = loadFont("Arial-MT",15);
  textFont(font);
  
  clear();
  if (sc == 50)
  {
    seconds++;
    sc=0;  
  }
  for(int k=0;k<bullets.size();k++)
  {
    Bullet b = bullets.get(k);
    if (b.alive)
      b.run();  
  }
  for(int j=0;j<targets.size();j++)
  {
    Target t = targets.get(j);
    if (t.alive)
      (targets.get(j)).show();  
  }
  for(int j=0;j<walls.size();j++)
  {
    (walls.get(j)).show();  
  }
  for(int i=0;i<cannons.size();i++)
  {
    (cannons.get(i)).show();
  }

  textAlign(LEFT);
  fill(255);
  text("Time: " + seconds,5,15);
  text("Points: " + points,5,30);
  if (bulletCounter > 0)
  {
    accuracy = int((hitCounter/bulletCounter)*100);
    int h = bulletCounter - hitCounter;
    int p = int(h/bulletCounter);
  }
  else if (bulletCounter == 0)
  {
    accuracy = 0;
  }
  //text("Accuracy: " + accuracy + "%", 5, 50);
  //text("Seconds: " + seconds, 5, 35);
    
  int enemiesAlive = 0;
  for(int j=0;j<targets.size();j++) {
    if (targets.get(j).alive)
      enemiesAlive ++;
  }
  if (enemiesAlive ==0) {
    win = true;
    playing = false;
  }

  stroke(100,100,255,125);
  for (int i=25;i<height; i+= 25) {
    strokeWeight(1);
    line(0,i,width,i);
  }
  stroke(255,100,100);
  line(width*0.85,0,width*0.85,height);
  sc++;

}
void mousePressed()
{
  if (playing)
  {
    for (int k=0;k<cannons.size();k++)
    {
      Cannon c = cannons.get(k);
      bullets.add(new Bullet(c,c.cX,c.cY));
      bulletCounter++;
      c.fire();
    }
  }

}

void gameover()
{
  int score = int(((points*seconds)*54.73)-((bulletCounter-hitCounter)*10));
  background(0);
  font = loadFont("Arial-MT",50);
  textFont(font);
  textAlign(CENTER);
  fill(255,255,0);
  if (win) {
    text("You Won!!", width/2, height/2-50);
  }
  else{
    text("You Lost!!", width/2, height/2-50);
  }

  text("Your score was: " + score, width/2, height/2-25);
  text("Press 'r' to Play Again!" , width/2, height/2+10);
}
void keyPressed()
{
  if (!playing)
  {
    if (key == 'r')
      setup();
  }
  else if (key == 'w') {
    for (int k=0;k<cannons.size();k++) {
      (cannons.get(k)).moveUp(speed);  
    }  
  }
  else if (key == 's') { 
    for (int k=0;k<cannons.size();k++) {
      (cannons.get(k)).moveDown(speed);  
    }
  }
  else if (key == 'a') {
    for (int k=0;k<cannons.size();k++) {
      (cannons.get(k)).moveLeft(speed);  
    }
  }
  else if (key == 'd') {
    for (int k=0;k<cannons.size();k++) {
      (cannons.get(k)).moveRight(speed);  
    }
  }
  else if (keyPressed&&key==CODED) {
    if (keyCode == UP) { 
      for (int k=0;k<cannons.size();k++) {
        (cannons.get(k)).moveUp(speed);  
      }
    } 
    if (keyCode == DOWN) {
      for (int k=0;k<cannons.size();k++) {
        (cannons.get(k)).moveDown(speed);  
      }
    }
    if (keyCode == LEFT) {
      for (int k=0;k<cannons.size();k++) {
        (cannons.get(k)).moveLeft(speed);  
      }
    }
    if (keyCode == RIGHT){
      for (int k=0;k<cannons.size();k++) {
        (cannons.get(k)).moveRight(speed);  
      }
    }
  }

}

void getTrack(int index) {
  var track = document.getElementById("track" + str(index));
  boolean canPlayWav = ("no" != track.canPlayType("audio/wav")) && ("" != track.canPlayType("audio/wav"));
  if (canPlayWav) {
    return track;
  }
  else {
    return document.getElementById("track1" + str(index));
  }
}  

</script><canvas></canvas>
<div style="height:0px;width:0px;overflow:hidden;"><img id="img1"><img id="img2"><img id="img3"></div>
</body> </html>
