<html>
<head>
<title>Knifetank!</title>
<script type="text/javascript" src="processing/processing-0.9.1.js"></script>
<script type="text/javascript" src="processing/init.js"></script>
<audio src="music/leveltwo01.wav" preload="true" id="track1"></audio>
<audio src="music/leveltwo02.wav" preload="true" id="track2"></audio>
<audio src="music/leveltwo03.wav" preload="true" id="track3"></audio>
<audio src="music/leveltwo04.wav" preload="true" id="track4"></audio>
<audio src="music/leveltwo05.wav" preload="true" id="track5"></audio>
<audio src="music/leveltwo01.ogg" preload="true" id="track11"></audio>
<audio src="music/leveltwo02.ogg" preload="true" id="track12"></audio>
<audio src="music/leveltwo03.ogg" preload="true" id="track13"></audio>
<audio src="music/leveltwo04.ogg" preload="true" id="track14"></audio>
<audio src="music/leveltwo05.ogg" preload="true" id="track15"></audio>
<style type="text/css">
body {background: #000 url("art_assets/knifetankbackground.png") no-repeat;}
</style>
<script type="application/processing">

int numAudioFiles = 5;
int audioIndex = 1;

boolean showBBs = true; // DEBUG: show bounding boxes.

PFont font = loadFont("Arial-MT",15);
PImage tank1;
PImage tank2;
PImage tank3;
PImage ghostank1;
PImage ghostank2;
PImage ghostank3;
ArrayList cannons;
ArrayList bullets;
ArrayList targets;
ArrayList walls;
ArrayList bloods;

int points = 0;
int bulletCounter = 0;
int hitCounter = 0;
float accuracy;
int seconds = 0;
int sc = 0;
int speed = 20;
boolean playing = false;
boolean win = false;

class Map
{
	var mapData;
	float width = 10;
	float height = 10;
	float objDist = 80;
	
	Map(var setMapData)
	{
		mapData = setMapData;
	}
}

Map map1 = new Map(
"OOOOOO##OO\
OTOOOO#OOO\
OOOOOO#OOC\
OTOOOO#OOO\
OOOOOO##OO\
OOO#OOOOOO\
OOO#OOOOOO\
OOO#OOOOOO\
OOOOOOOOOO\
OOOOOOOOOO");

class Wall {
  float x;
  float y;
  float d = 70;
  boolean on;
  boolean toggleable;
  Wall(float X, float Y, boolean toggle) {
    x = X+d/2;
    y = Y+d/2;
    toggleable = toggle;
    on = true;
  }
  float top()    { return y - d/2; }
  float bottom() { return y + d/2; }
  float left()   { return x - d/2; }
  float right()  { return x + d/2; }

  boolean intersect(PVector p1, PVector p2) {
    return false;
  }
  void show() {
    stroke(0,0,0,255);
    strokeWeight(2);
    int hue = 200;
    if (on) {
      fill(255,255,0);
    }
    else {
      fill(255,0,255);
    }
    rect(x-d/2,y-d/2,d,d);

    for (int i=0;i<bullets.size();i++) {
      Bullet b = bullets.get(i);
      PVector l = new PVector(b.loc.x,b.loc.y);
      if (l.x>=x-d/2&&l.x<=x+d/2&&l.y >=y-d/2&&l.y<=y+d/2) {
  
        if (toggleable) {
          on = !on;

          // switch to the next audio track
          var prev = getTrack(audioIndex);
          audioIndex += 1;
          if (audioIndex > numAudioFiles)
            audioIndex = 1;
          var next = getTrack(audioIndex);
          next.volume = 0;
          next.play();
          next.currentTime = prev.currentTime;  
          next.volume = 1;
          prev.volume = 0;
          prev.pause();
        }

        // reflect the bullet
        PVector dir = new PVector(b.dir.x,b.dir.y);
        if (dir.x == 0) {
          (bullets.get(i)).flipy(); 
        }
        else if (dir.y == 0) {
          (bullets.get(i)).flipx(); 
        }
        else {
          float dx = 0;
          if (dir.x > 0) {
            dx = l.x - (x-d/2);
          }
          else {
            dx = l.x - (x+d/2);
          }
          float dy = dx*dir.y/dir.x;         

          float yy = l.y - dy;
          if (yy==y-d/2 || yy == y+d/2) {
            (bullets.get(i)).flipx();
            (bullets.get(i)).flipy();
          } 
          else if (yy>y-d/2 && yy < y+d/2) {
            (bullets.get(i)).flipx();
          }
          else {
            (bullets.get(i)).flipy(); 
          }
        }
      }  
    }
  }
}

class Bullet
{
  PVector loc = new PVector();
  PVector dir = new PVector();
  float angle;
  Cannon c;
  int age = 0;
  boolean alive;
  Bullet(Cannon c, float x, float y)
  {
    this.c = c;
    loc.x = x;
    loc.y = y;
    PVector center = new PVector(c.loc.x,c.loc.y);
    PVector turret = new PVector(c.cX,c.cY);
    dir = PVector.sub(turret, center);
    alive = true;
  }
  void run()
  {
    noStroke();
    fill(100);
    ellipse(loc.x,loc.y,10,10);
    loc.add(new PVector(dir.x/4,dir.y/4));
    if (loc.x < 0 || loc.x > width)
      flipx();
    if (loc.y < 0 || loc.y > height)
      flipy();
    age++;
    if (age>100)  alive = false;
  }
  void flipx()
  {
    dir.x = -dir.x;
  }
  void flipy()
  {
    dir.y = -dir.y;
  }
}

class Target
{
  PVector loc;
  PVector dest;
  float d = 70;
  int lives;
  boolean alive;
  float speed = 3;
  int sprite = 0;
  float angle = 0; // angle to which we rotate to draw the sprite. radians.
  int lastDirChange = 0;

  Target(float X, float Y, int LIVES)
  {
    loc = new PVector();
    loc.x = X;
    loc.y = Y;
    dest = new PVector();
    dest.x = random(width);
    dest.y = random(height);
    this.lives = LIVES;
    alive = true;
  }

  float top()    { return loc.y - d/2; }
  float bottom() { return loc.y + d/2; }
  float left()   { return loc.x - d/2; }
  float right()  { return loc.x + d/2; }

  void show()
  {
     // This loop moves enemies "intelligently"
     bool attack = false;
     for (int i = 0; i < cannons.size(); ++i) {
       Cannon c = cannons.get(i);
       if (loc.dist(c.loc) < 300) {
         dest.x = c.loc.x;
         dest.y = c.loc.y;
         attack = true;
       }
     }
     boolean timeout = (seconds - lastDirChange > 3);
     boolean arrived = loc.dist(dest) < d;
     if (!attack && ( timeout || arrived )) {
         dest.x = random(width);
         dest.y = random(height);
         lastDirChange = seconds;
     }

     moveToward(dest.x,dest.y); 

    translate(loc.x,loc.y);
    rotate(angle);
    switch (sprite) {
      case 0: image(ghostank1,-d/2,-d/2); break;
      case 1: image(ghostank2,-d/2,-d/2); break;
      case 2: image(ghostank3,-d/2,-d/2); break;
    }
    if (sc % 2 == 0) {
     sprite = (sprite+1)%3;
    }
    rotate(-angle);
    translate(-loc.x,-loc.y);
    
    if (showBBs) {
      strokeWeight(1);
      noFill();
      stroke(0,0,255);
      rect(loc.x-d/2,loc.y-d/2,d,d);
    }
    for (int i=0;i<bullets.size();i++)
    {
      Bullet b = bullets.get(i);
      if (!b.alive) continue;

      PVector l = new PVector(b.loc.x,b.loc.y);
      if (l.x>=left()&&l.x<=right()&&l.y >=top()&&l.y<=bottom()) {
        lives--;
        hitCounter++;
        bullets.remove(b);
        if (lives <= 0) { 
          points++;
          alive = false;
	  //Spawn blood effect when enemy dies
	  bloods.add(new ParticleSystem(200, new Vector3D(loc.x,loc.y,0)));
        }  
      }  
    }
    for (int i=0;i<cannons.size();i++)
    {
      fill(255);
      Cannon c = cannons.get(i);
      float minx = left()   - c.d/2;
      float maxx = right()  + c.d/2;
      float miny = top()    - c.d/2;
      float maxy = bottom() + c.d/2;

      if (c.loc.x>=minx && c.loc.x<=maxx && c.loc.y >= miny && c.loc.y <= maxy)
      {
         playing = false;
      }  
    }

  }

  void moveToward(float x, float y) {
       float oldx = loc.x;
       float oldy = loc.y;
       if (x < left()) {
         moveLeft(speed);
         angle = PI/2;        
         if (loc.x != oldx || loc.y != oldy) {
            return;
         }
       }
       if (x > right()) {
         moveRight(speed); 
         angle = -PI/2;
         if (loc.x != oldx || loc.y != oldy) {
            return;   
         }
       }
       if (y < top()) {
         moveUp(speed);  
         angle = PI;
         if (loc.x != oldx || loc.y != oldy) {
            return;
         }
       }
       if (y > bottom()) {
         moveDown(speed);
         angle = 0;
         if (loc.x != oldx || loc.y != oldy) {
            return;
         }
       }
  }

 void moveUp(float dy) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.left()   - d/2;
      float maxx = wall.right()  + d/2;
      float miny = wall.bottom() + d/2;
      float maxy = wall.bottom() + d/2 + dy;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dy = top() - wall.bottom() - 1;
      }
    }
    loc.y -= dy

    if (top() < 0) {
      loc.y = d/2;
    } 
  }

  void moveDown(float dy) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.left() - d/2;
      float maxx = wall.right() + d/2;
      float miny = wall.top() - d/2 - dy;
      float maxy = wall.top() - d/2;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dy = wall.top() - bottom() - 1;
      }
    }
    loc.y += dy

    if (bottom() > height) {
      loc.y = height-d/2;
    }
  }

  void moveLeft(float dx) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.right()  + d/2;
      float maxx = wall.right()  + d/2 + dx;
      float miny = wall.top()    - d/2;
      float maxy = wall.bottom() + d/2;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dx = left() - wall.right() - 1;
      }
    }
    loc.x -= dx

    if (left() < 0) {
      loc.x = d/2;
    }
  }
  void moveRight(float dx) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.left()   - d/2 - dx;
      float maxx = wall.left()   - d/2;
      float miny = wall.top()    - d/2;
      float maxy = wall.bottom() + d/2;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dx = wall.left() - right() - 1;
      }
    }
    loc.x += dx

    if (right() > width) {
      loc.x = width-d/2;
    }
  }
}

class Cannon {
  float d;
  float r;
  float cX;
  float cY;
  PVector loc = new PVector();
  int sprite = 0;
  float baseAngle = 0;
  float firing = 0;
  Cannon(float x, float y) {
    d = 70;
    r = d/2;
    loc.x = x;
    loc.y = y;
  }
  float top()    { return loc.y - d/2; }
  float bottom() { return loc.y + d/2; }
  float left()   { return loc.x - d/2; }
  float right()  { return loc.x + d/2; }

  void show() {
    smooth();

    float angle = atan2(mouseY-loc.y,mouseX-loc.x);

    cX = (r * cos(angle)) + loc.x;
    cY = (r * sin(angle)) + loc.y;

    translate(loc.x,loc.y);
    rotate(baseAngle-PI/2);
    switch (sprite) {
      case 0: image(tank1,-d/2,-d/2); break;
      case 1: image(tank2,-d/2,-d/2); break;
      case 2: image(tank3,-d/2,-d/2); break;
    }
    rotate(-baseAngle+PI/2);
    switch (firing) {
      //case 0: image(turret1,-d/2,-d/2); break;
      //case 1: image(turret2,-d/2,-d/2); break;
      //case 2: image(turret3,-d/2,-d/2); break;
      //case 3: image(turret3,-d/2,-d/2); break;
    }
    if (firing > 0) --firing;
    rotate(angle - PI/2);
    // draw the turret sprite here.
    rotate(-angle+PI/2);
    translate(-loc.x,-loc.y);
    
    if (showBBs) {
      // show bounding box
      noFill();
      strokeWeight(1);
      stroke(0,255,0);
      rect(loc.x-d/2,loc.y-d/2,d,d);
      line(loc.x,loc.y,cX,cY);
    }
  }  
  
 void moveUp(float dy) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.left()   - d/2;
      float maxx = wall.right()  + d/2;
      float miny = wall.bottom() + d/2;
      float maxy = wall.bottom() + d/2 + dy;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dy = top() - wall.bottom();
      }
    }
    loc.y -= dy

    if (top() < 0) {
      loc.y = d/2;
    }
    sprite = (sprite+1)%3;
    baseAngle = -PI/2;
  }

  void moveDown(float dy) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.left() - d/2;
      float maxx = wall.right() + d/2;
      float miny = wall.top() - d/2 - dy;
      float maxy = wall.top() - d/2;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dy = wall.top() - bottom() - 1;
      }
    }
    loc.y += dy

    if (bottom() > height) {
      loc.y = height-d/2;
    }
    sprite = (sprite+1)%3;
    baseAngle = PI/2;
  }

  void moveLeft(float dx) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.right()  + d/2;
      float maxx = wall.right()  + d/2 + dx;
      float miny = wall.top()    - d/2;
      float maxy = wall.bottom() + d/2;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dx = left() - wall.right() - 1;
      }
    }
    loc.x -= dx

    if (left() < 0) {
      loc.x = d/2;
    }
    sprite = (sprite+1)%3;
    baseAngle = PI;
  }
  void moveRight(float dx) {
    for (int i=0;i<walls.size();++i) {
      Wall wall = walls.get(i);
      float minx = wall.left()   - d/2 - dx;
      float maxx = wall.left()   - d/2;
      float miny = wall.top()    - d/2;
      float maxy = wall.bottom() + d/2;
      if (loc.x >= minx && loc.x <= maxx && loc.y >= miny && loc.y <= maxy) {
        dx = wall.left() - right() - 1;
      }
    }
    loc.x += dx

    if (right() > width) {
      loc.x = width-d/2;
    }
    sprite = (sprite+1)%3;
    baseAngle = 0;
  }

  void fire() {
     firing = 3;
  } 
}

void setup() {
  cannons = new ArrayList();
  bullets = new ArrayList();
  targets = new ArrayList();
  walls   = new ArrayList();
  bloods = new ArrayList();
  points = 0;
  targetInterval = 150;
  counter = 0;
  bulletCounter = 0;
  hitCounter = 0;
  accuracy = 0;
  seconds = 0;
  sc = 0;
  c = 0;
  speed = 10;
  size(960,640);
  cursor(CROSS);
  textFont(font);
  
  generateMap(map1);
  
  win = false;
  playing = true;
  frameRate(50);

  tank1 = loadImage("art_assets/tank01sm.png");
  tank2 = loadImage("art_assets/tank02sm.png");
  tank3 = loadImage("art_assets/tank03sm.png");
  ghostank1 = loadImage("art_assets/ghostank01sm.png");
  ghostank2 = loadImage("art_assets/ghostank02sm.png");
  ghostank3 = loadImage("art_assets/ghostank03sm.png");

  var audioElement = getTrack(1);
  audioElement.load();
  audioElement.loop = true;
  audioElement.volume = 1;
  audioElement.play();

  for (int i=2; i <= numAudioFiles; ++i) {
    var audioElement = document.getElementById("track"+str(i));
    audioElement.load();
    audioElement.loop = true;
    audioElement.volume = 0;
  }
}

void generateMap(Map fromMap)
{
    for (x=0; x<fromMap.mapData.length; x++)
    {
        c = fromMap.mapData.charAt(x);
	if (c == "#")
	{
	    walls.add(new Wall((x % fromMap.width) * fromMap.objDist, floor((x / fromMap.height)) * fromMap.objDist,true));
	}
	else if (c == "T")
	{
            targets.add(new Target((x % fromMap.width) * fromMap.objDist, floor((x / fromMap.height)) * fromMap.objDist,1));
	}
	else if (c == "C")
	{
	    cannons.add(new Cannon((x % fromMap.width) * fromMap.objDist, floor((x / fromMap.height)) * fromMap.objDist));
	}
    }
}

void draw()
{
  if (playing)
    play();
  else
    gameover();
}

void play()
{
  font = loadFont("Arial-MT",15);
  textFont(font);
  
  clear();
  if (sc == 50)
  {
    seconds++;
    sc=0;  
  }
  for(int k=0;k<bullets.size();k++)
  {
    Bullet b = bullets.get(k);
    if (b.alive)
      b.run();  
  }
  for(int j=0;j<targets.size();j++)
  {
    Target t = targets.get(j);
    if (t.alive)
      (targets.get(j)).show();  
  }
  for(int j=0;j<walls.size();j++)
  {
    (walls.get(j)).show();  
  }
  for(int i=0;i<cannons.size();i++)
  {
    (cannons.get(i)).show();
  }

  textAlign(LEFT);
  fill(255);
  text("Time: " + seconds,5,15);
  text("Points: " + points,5,30);
  if (bulletCounter > 0)
  {
    accuracy = int((hitCounter/bulletCounter)*100);
    int h = bulletCounter - hitCounter;
    int p = int(h/bulletCounter);
  }
  else if (bulletCounter == 0)
  {
    accuracy = 0;
  }
  //text("Accuracy: " + accuracy + "%", 5, 50);
  //text("Seconds: " + seconds, 5, 35);
    
  int enemiesAlive = 0;
  for(int j=0;j<targets.size();j++) {
    if (targets.get(j).alive)
      enemiesAlive ++;
  }
  if (enemiesAlive ==0) {
    win = true;
    playing = false;
  }

  stroke(100,100,255,125);
  for (int i=25;i<height; i+= 25) {
    strokeWeight(1);
    line(0,i,width,i);
  }
  stroke(255,100,100);
  line(width*0.85,0,width*0.85,height);
  sc++;

  for (int i=0;i<bloods.size();)
  {
    ParticleSystem b = bloods.get(i);
    b.run();
    if (b.dead())
    {
	bloods.remove(i);
    }
    else
    {
        i++;
    }
  }
}
void mousePressed()
{
  if (playing)
  {
    for (int k=0;k<cannons.size();k++)
    {
      Cannon c = cannons.get(k);
      bullets.add(new Bullet(c,c.cX,c.cY));
      bulletCounter++;
      c.fire();
    }
  }

}

void gameover()
{
  int score = int(((points*seconds)*54.73)-((bulletCounter-hitCounter)*10));
  background(0);
  font = loadFont("Arial-MT",50);
  textFont(font);
  textAlign(CENTER);
  fill(255,255,0);
  if (win) {
    text("You Won!!", width/2, height/2-50);
  }
  else{
    text("You Lost!!", width/2, height/2-50);
  }

  text("Your score was: " + score, width/2, height/2-25);
  text("Press 'r' to Play Again!" , width/2, height/2+10);
}
void keyPressed()
{
  if (!playing)
  {
    if (key == 'r')
      setup();
  }
  else if (key == 'w') {
    for (int k=0;k<cannons.size();k++) {
      (cannons.get(k)).moveUp(speed);  
    }  
  }
  else if (key == 's') { 
    for (int k=0;k<cannons.size();k++) {
      (cannons.get(k)).moveDown(speed);  
    }
  }
  else if (key == 'a') {
    for (int k=0;k<cannons.size();k++) {
      (cannons.get(k)).moveLeft(speed);  
    }
  }
  else if (key == 'd') {
    for (int k=0;k<cannons.size();k++) {
      (cannons.get(k)).moveRight(speed);  
    }
  }
  else if (keyPressed&&key==CODED) {
    if (keyCode == UP) { 
      for (int k=0;k<cannons.size();k++) {
        (cannons.get(k)).moveUp(speed);  
      }
    } 
    if (keyCode == DOWN) {
      for (int k=0;k<cannons.size();k++) {
        (cannons.get(k)).moveDown(speed);  
      }
    }
    if (keyCode == LEFT) {
      for (int k=0;k<cannons.size();k++) {
        (cannons.get(k)).moveLeft(speed);  
      }
    }
    if (keyCode == RIGHT){
      for (int k=0;k<cannons.size();k++) {
        (cannons.get(k)).moveRight(speed);  
      }
    }
  }

}

void getTrack(int index) {
  var track = document.getElementById("track" + str(index));
  boolean canPlayWav = ("no" != track.canPlayType("audio/wav")) && ("" != track.canPlayType("audio/wav"));
  if (canPlayWav) {
    return track;
  }
  else {
    return document.getElementById("track1" + str(index));
  }
}

// A simple Particle class  
  
class Particle {  
  Vector3D loc;  
  Vector3D vel;  
  Vector3D acc;  
  float r;  
  float timer;  
  
  // One constructor  
  Particle(Vector3D a, Vector3D v, Vector3D l, float r_) {  
    acc = a.copy();  
    vel = v.copy();  
    loc = l.copy();  
    r = r_;  
    timer = 100.0;  
  }  
    
  // Another constructor (the one we are using here)  
  Particle(Vector3D l) {  
    acc = new Vector3D(0,0.05,0);  
    vel = new Vector3D(random(-1,1),random(-2,0),0);  
    loc = l.copy();  
    r = 10.0;  
    timer = 100.0;  
  }  
  
  
  void run() {  
    update();  
    render();  
  }  
  
  // Method to update location  
  void update() {  
    vel.add(acc);  
    loc.add(vel);  
    timer -= 1.0;  
  }  
  
  // Method to display  
  void render() {  
    //ellipseMode(CENTER);  
    noStroke();  
    fill(#FF0000,timer);
    rect(loc.x, loc.y, r, r);
    ellipse(loc.x,loc.y,r,r);  
  }  
    
  // Is the particle still useful?  
  boolean dead() {  
    if (timer <= 0.0) {  
      return true;  
    } else {  
      return false;  
    }  
  }  
}  
  
  
// A class to describe a group of Particles  
// An ArrayList is used to manage the list of Particles   
  
class ParticleSystem {  
  
  ArrayList particles;    // An arraylist for all the particles  
  Vector3D origin;        // An origin point for where particles are birthed  
  
  ParticleSystem(int num, Vector3D v) {  
    particles = new ArrayList();              // Initialize the arraylist  
    origin = v.copy();                        // Store the origin point  
    for (int i = 0; i < num; i++) {  
      particles.add(new Particle(origin));    // Add "num" amount of particles to the arraylist  
    }  
  }  
  
  void run() {  
    // Cycle through the ArrayList backwards b/c we are deleting  
    for (int i = particles.size()-1; i >= 0; i--) {  
      Particle p = (Particle) particles.get(i);  
      p.run();  
      if (p.dead()) {  
        particles.remove(i);  
      }  
    }  
  }  
  
  void addParticle() {  
    particles.add(new Particle(origin));  
  }  
  
  void addParticle(Particle p) {  
    particles.add(p);  
  }  
  
  // A method to test if the particle system still has particles  
  boolean dead() {  
    if (particles.isEmpty()) {  
      return true;  
    } else {  
      return false;  
    }  
  }  
  
}  
  
  
  
// Simple Vector3D Class   
  
public class Vector3D {  
  public float x;  
  public float y;  
  public float z;  
  
  Vector3D(float x_, float y_, float z_) {  
    x = x_; y = y_; z = z_;  
  }  
  
  Vector3D(float x_, float y_) {  
    x = x_; y = y_; z = 0f;  
  }  
    
  Vector3D() {  
    x = 0f; y = 0f; z = 0f;  
  }  
  
  void setX(float x_) {  
    x = x_;  
  }  
  
  void setY(float y_) {  
    y = y_;  
  }  
  
  void setZ(float z_) {  
    z = z_;  
  }  
    
  void setXY(float x_, float y_) {  
    x = x_;  
    y = y_;  
  }  
    
  void setXYZ(float x_, float y_, float z_) {  
    x = x_;  
    y = y_;  
    z = z_;  
  }  
  
  void setXYZ(Vector3D v) {  
    x = v.x;  
    y = v.y;  
    z = v.z;  
  }  
  public float magnitude() {  
    return (float) Math.sqrt(x*x + y*y + z*z);  
  }  
  
  public Vector3D copy() {  
    return new Vector3D(x,y,z);  
  }  
  
  public Vector3D copy(Vector3D v) {  
    return new Vector3D(v.x, v.y,v.z);  
  }  
    
  public void add(Vector3D v) {  
    x += v.x;  
    y += v.y;  
    z += v.z;  
  }  
  
  public void sub(Vector3D v) {  
    x -= v.x;  
    y -= v.y;  
    z -= v.z;  
  }  
  
  public void mult(float n) {  
    x *= n;  
    y *= n;  
    z *= n;  
  }  
  
  public void div(float n) {  
    x /= n;  
    y /= n;  
    z /= n;  
  }  
  
  public void normalize() {  
    float m = magnitude();  
    if (m > 0) {  
       div(m);  
    }  
  }  
  
  public void limit(float max) {  
    if (magnitude() > max) {  
      normalize();  
      mult(max);  
    }  
  }  
  
  public float heading2D() {  
    float angle = (float) Math.atan2(-y, x);  
    return -1*angle;  
  }  
  
  public Vector3D add(Vector3D v1, Vector3D v2) {  
    Vector3D v = new Vector3D(v1.x + v2.x,v1.y + v2.y, v1.z + v2.z);  
    return v;  
  }  
  
  public Vector3D sub(Vector3D v1, Vector3D v2) {  
    Vector3D v = new Vector3D(v1.x - v2.x,v1.y - v2.y,v1.z - v2.z);  
    return v;  
  }  
  
  public Vector3D div(Vector3D v1, float n) {  
    Vector3D v = new Vector3D(v1.x/n,v1.y/n,v1.z/n);  
    return v;  
  }  
  
  public Vector3D mult(Vector3D v1, float n) {  
    Vector3D v = new Vector3D(v1.x*n,v1.y*n,v1.z*n);  
    return v;  
  }  
  
  public float distance (Vector3D v1, Vector3D v2) {  
    float dx = v1.x - v2.x;  
    float dy = v1.y - v2.y;  
    float dz = v1.z - v2.z;  
    return (float) Math.sqrt(dx*dx + dy*dy + dz*dz);  
  }  
  
}

</script><canvas></canvas>
<div style="height:0px;width:0px;overflow:hidden;"><img id="img1"><img id="img2"><img id="img3"></div>
</body> </html>
